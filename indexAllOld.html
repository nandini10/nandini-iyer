<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First Person Maze Runner</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, maze, mazeData;
        let moveForward = false, moveBackward = false, turnLeft = false, turnRight = false;
        let clock = new THREE.Clock();
        let velocity = new THREE.Vector3();
        let speed = 0.1;
        let turnSpeed = 0.05;

        // Player position in the maze grid
        let playerGridX = 1, playerGridZ = 1; // Start position (on a path)

        init();
        animate();

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xAAAAAA);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 1.6, 10); // Start slightly above ground level in the maze

            // Renderer setup
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Generate maze
            mazeData = generateMaze(21, 21); // Create a 21x21 maze
            maze = new THREE.Group();
            createMazeWalls(mazeData);
            scene.add(maze);

            // Event listeners for key controls
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);

            // Adjust camera on resize
            window.addEventListener('resize', onWindowResize, false);

            // Ensure the camera starts on a path
            setStartingPosition();
        }

        function setStartingPosition() {
            // Find a valid starting position on the path (where mazeData is 0)
            for (let y = 0; y < mazeData.length; y++) {
                for (let x = 0; x < mazeData[y].length; x++) {
                    if (mazeData[y][x] === 0) { // If the position is a path (0)
                        playerGridX = x;
                        playerGridZ = y;
                        camera.position.set(x + 0.5, 1.6, y + 0.5); // Offset for better placement in the center of the path
                        return;
                    }
                }
            }
        }

        function generateMaze(width, height) {
            // Create a grid full of walls
            let maze = Array.from({ length: height }, () => Array(width).fill(1));

            // Recursive backtracking algorithm to carve out paths
            function carve(x, y) {
                let directions = [
                    [0, 1], [1, 0], [0, -1], [-1, 0]
                ];
                directions = shuffle(directions);

                for (let [dx, dy] of directions) {
                    let nx = x + dx * 2, ny = y + dy * 2;
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height && maze[ny][nx] === 1) {
                        maze[ny][nx] = 0;
                        maze[y + dy][x + dx] = 0;
                        carve(nx, ny);
                    }
                }
            }

            // Start carving from (1, 1)
            maze[1][1] = 0;
            carve(1, 1);
            return maze;
        }

        function shuffle(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function createMazeWalls(mazeData) {
            // Load wall texture
            const loader = new THREE.TextureLoader();
            const wallTexture = loader.load('wall_texture.jpg'); // Ensure this file exists

            // Set texture to repeat
            wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
            wallTexture.repeat.set(1, 1); // Adjust the number of repetitions (you can change this value)

            const wallMaterial = new THREE.MeshBasicMaterial({ map: wallTexture, side: THREE.DoubleSide });

            for (let y = 0; y < mazeData.length; y++) {
                for (let x = 0; x < mazeData[y].length; x++) {
                    if (mazeData[y][x] === 1) {
                        // Create a wall at this position
                        let wall = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), wallMaterial);
                        wall.position.set(x, 1, y); // Wall positions
                        maze.add(wall);
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta(); // Time elapsed since the last frame
            velocity.set(0, 0, 0);

            // Get the direction the camera is facing
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);

            // Move the camera forward/backward, but first check for collisions
            if (moveForward && canMoveTo(playerGridX, playerGridZ, direction.x, direction.z)) velocity.z -= speed;
            if (moveBackward && canMoveTo(playerGridX, playerGridZ, -direction.x, -direction.z)) velocity.z += speed;

            // Turn the camera left/right
            if (turnLeft) camera.rotation.y += turnSpeed;
            if (turnRight) camera.rotation.y -= turnSpeed;

            // Apply velocity to camera position
            camera.translateZ(velocity.z);

            renderer.render(scene, camera);
        }

        // Grid-based collision detection
        function canMoveTo(x, z, dx, dz) {
            const newX = Math.floor(x + dx);
            const newZ = Math.floor(z + dz);

            if (newX >= 0 && newX < mazeData[0].length && newZ >= 0 && newZ < mazeData.length) {
                // Check if the new position is a valid path (0)
                console.log('can move', newZ, newX, mazeData);
                if (mazeData[newZ][newX] === 0) {
                    console.log('can move');
                    return true; // Can move to the new position
                }
            }
            console.log('cant move');
            return false; // Blocked by a wall or out of bounds
        }

        function onKeyDown(event) {
            switch (event.key) {
                case 'ArrowUp':
                    moveForward = true;
                    break;
                case 'ArrowDown':
                    moveBackward = true;
                    break;
                case 'a':
                    turnLeft = true;
                    break;
                case 'd':
                    turnRight = true;
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.key) {
                case 'ArrowUp':
                    moveForward = false;
                    break;
                case 'ArrowDown':
                    moveBackward = false;
                    break;
                case 'a':
                    turnLeft = false;
                    break;
                case 'd':
                    turnRight = false;
                    break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
